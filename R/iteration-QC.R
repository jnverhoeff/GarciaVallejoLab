#' @title Run unimodality quality control on metaclusterings in parallel
#'
#' @description Unimodality score is calculated for all calculated metaclusterings.
#'
#' @param FlowSOM.results A FlowSOM object with completed SOM clustering, either after full FlowSOM function or after BuildSOM
#' @param metaclustering.list List of metaclustering results, as generated by \link{iteration.metacluster}
#' @param set.i Vector containing either the desired iterations to be tested
#' @param multicore logical, should INFLECT be run in parallel using \link[doParallel]{registerDoParallel}. Default is \code{TRUE}
#' @param cores If \code{multicore == TRUE}, number of cores to be used. If \code{NULL} max number of cores-1 is used.
#' @param zeroes.in Should be values at and below \code{0} be included. Recommeded default for mass cytometry data is \code{FALSE}
#' @param only.clustering.markers If \code{TRUE} only evaluates markers specified in FlowSOM.results$map$colsUsed
#' @param acquired_markers Vector of column names with marker data to be evaluated by INFLECT. Ignored if \code{only.clustering.markers == TRUE}
#' @param uniform.test What tests are performed per marker per cluster. Options are "both", "spread" , or "unimodality" as a string.
#' @param th.pvalue Threshold for rejecting Unimodality dip.test result. Default is \code{0.05}. For more information see \link[diptest]{dip.test}
#' @param th.IQR Threshold for rejecting marker distribution based on inter-quartile range. Default is arc-sinh transformed value of \code{2}.
#' @param verbose \code{logical} , default is \code{FALSE}
#' @param ... Additional arguments to pass to this function. Not used currently.
#'
#' @return A \code{list} with 2 items. The first is the unimodality scores stored in U.set. Second is a \code{list} with a \code{logical} matrix for each metaclustering result.
#' @seealso \code{\link{INFLECT}}, \code{\link{iteration.metacluster}}, \code{\link{FlowSOMQC}}
#'
#' @export
iteration.QC<- function(FlowSOM.results, metaclustering.list,set.i, multicore= TRUE, cores=NULL, zeroes.in=FALSE,only.clustering.markers = TRUE, acquired_markers=NULL, uniform.test = "both", th.pvalue = 0.05, th.IQR = 2, verbose = FALSE, ...){

  if(multicore){
    if(is.null(cores)) {cores <- parallel::detectCores() -1 } else{ cores<-cores
    }
    registerDoParallel(cores= cores)


    accuracy.set<- foreach(Ui = set.i, .final = function(x) {setNames(x, set.i)}) %dopar% {

      metaclustering <- metaclustering.list[[as.character(Ui)]]
      FlowSOMQC(FlowSOM.results = FlowSOM.results, metaclustering= metaclustering, zeroes.in=zeroes.in, only.clustering.markers = only.clustering.markers, acquired_markers=acquired_markers, uniform.test = uniform.test, th.pvalue = th.pvalue, th.IQR = th.IQR, verbose = verbose)

    }

    U.set<- foreach(Ui = set.i, .final = function(x) {setNames(x, set.i)}) %dopar% {

      matrix<- accuracy.set[[as.character(Ui)]]
      return(sum(matrix, na.rm=TRUE)*100 / prod(dim(matrix)))

    }
    U.set<- data.frame("i"= as.numeric(names(U.set)), "Unimodality"= unlist(U.set))
  } else{
    accuracy.set<- list()
    for ( Ui in set.i){
      metaclustering <- metaclustering.list[[as.character(Ui)]]
      qc<- FlowSOMQC(FlowSOM.results = FlowSOM.results, metaclustering= metaclustering, zeroes.in=zeroes.in, only.clustering.markers = only.clustering.markers, acquired_markers=acquired_markers, uniform.test = uniform.test, th.pvalue = th.pvalue, th.IQR = th.IQR, verbose = verbose)
      accuracy.set[[Ui]] <- qc
    }
    accuracy.set <- accuracy.set[!sapply(accuracy.set, is.null)]
    accuracy.set <- setNames(accuracy.set, as.character(set.i))

    U.set<- list()
    for (Ui in set.i){
      matrix<- accuracy.set[[as.character(Ui)]]
      U.set[[Ui]]<- sum(matrix, na.rm=TRUE) *100 / prod(dim(matrix))
    }
    U.set <- U.set[!sapply(U.set, is.null)]
    U.set <- setNames(U.set, as.character(set.i))
    U.set<- data.frame("i"= as.numeric(names(U.set)), "Unimodality"= unlist(U.set))
  }
  return(list("U.set"= U.set,"Accuracy.matrixes"=accuracy.set))
}
