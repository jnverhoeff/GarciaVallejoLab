#' @title Run the INFLECT computation
#'
#' @description Wrapper function combining all aspects of INFLECT, iterative clustering, unimodality testing and inflection point determination.
#' Default options include fewer calculations at higher cluster numbers, zeroes are removed and inflection point is calculated on the fitted curve.
#'
#' @param FlowSOM.results A FlowSOM object with completed SOM clustering, either after full FlowSOM function or after BuildSOM
#' @param set.i Vector containing either the desired iterations to be tested, or if \code{length(set.i)==2}, the point where iterations are spaced apart by 5 or 10. Intended to limit computation time
#' @param multicore logical, should INFLECT be run in parallel using \link[doParallel]{registerDoParallel}
#' @param cores If \code{multicore == TRUE}, number of cores to be used. If \code{NULL} max number of cores-1 is used
#' @param zeroes.in Should be values at and below \code{0} be included. Recommeded default is \code{FALSE}
#' @param only.clustering.markers If \code{TRUE} only evaluates markers specified in FlowSOM.results$map$colsUsed
#' @param acquired_markers Vector of column names with marker data to be evaluated by INFLECT. Ignored if \code{only.clustering.markers == TRUE}
#' @param basedata Data to be used to calculate inflection point, given as a string. Options are \code{Curve} and \code{Points}
#' @param ggtitle Optional title for resulting diagnostic graph. Default \code{NULL}
#' @param ... Arguments to pass to \code{\link{FlowSOMQC}} (uniform.test, th.pvalue, th.IQR)
#'
#' @return A \linkS4class{inflect.results} object containing a dataframe with Unimodality scores, a dataframe with the fitted curve,  the \code{\link{Lfunction}} results, the diagnostic \pkg{ggplot2} plot, the \code{list} of metaclusterings performed during \code{\link{iteration.metacluster}}, and a \code{list} of accuracy matrices generated by \code{\link{FlowSOMQC}}
#' Running the individual function \code{\link{iteration.metacluster}} and \code{\link{QC.to.curve}} might provide more options and flexibility.
#'
#' @seealso \code{\link{iteration.metacluster}}, \code{\link{iteration.QC}}, \code{\link{FlowSOMQC}}, \code{\link{QC.to.curve}}, \code{\link{leastError}}, \code{\link{Lfunction}}, \code{\link{marker.performance}}
#'
#' @examples
#'
#' # Read in FlowSOM object from file. Downsampled clustering result of Levine32 dataset clustering.
#' # SOM-clustered to 375 clusters.
#' flowsom <- system.file("extdata", "Levine32sample.Rdata", package="INFLECT")
#' load(flowsom)
#' set.i<- c( seq(5, 50), seq(55,100,5), seq(110,200, 10))
#' inflect.results<- INFLECT(FlowSOM.results= dataset, set.i= set.i, multicore=TRUE, cores=4, zeroes.in=FALSE)
#'
#' # Display diagnostic graph
#' inflect.results$ggplot
#'
#' @import flowCore
#' @import FlowSOM
#' @import ggplot2
#' @importFrom parallel detectCores
#' @importFrom doParallel registerDoParallel
#' @importFrom foreach '%dopar%'
#' @importFrom foreach foreach
#' @importFrom drc drm
#' @importFrom LearnGeom LinesAngles
#' @importFrom gtools mixedsort
#' @importFrom diptest dip.test
#' @importFrom RColorBrewer brewer.pal
#' @importFrom reshape2 melt
#' @importFrom stats lm fitted predict resid setNames
#'
#'
#' @export
INFLECT <-
  function(FlowSOM.results, set.i = c(150, 200), multicore = TRUE, cores = NULL, zeroes.in = FALSE, only.clustering.markers = TRUE, acquired_markers = NULL, basedata = "Curve", ggtitle = NULL, ...) {
    if (is.null(set.i)) {
      stop("Error in iteration.metacluster: The 'set.i' parameter can not be NULL")
    } else if (length(set.i) == 2 &
               set.i[2] < 0.9 * FlowSOM.results$map$nNodes) {
      set.i <-
        c(
          seq(5, set.i[1]),
          seq(set.i[1] + 5, set.i[2], 5),
          seq(set.i[2] + 10, FlowSOM.results$map$nNodes * 0.9, 10)
        )
    }
    else if (length(set.i) == 2) {
      set.i <-
        c(seq(5, set.i[1]),
          seq(set.i[1] + 5, FlowSOM.results$map$nNodes * 0.9, 5))
    } else if (length(set.i) < 50) {
      warning("Warning: Number of points in set.i is low, beware of noisy diagnostic curves ")
    }


    metaclustering.list <-
      iteration.metacluster(
        FlowSOM.results = FlowSOM.results,
        set.i = set.i,
        multicore = multicore,
        cores = cores
      )

    collection.U <-
      iteration.QC(
        FlowSOM.results = FlowSOM.results,
        metaclustering.list = metaclustering.list,
        set.i = set.i,
        multicore = multicore,
        cores = cores,
        zeroes.in = zeroes.in,
        only.clustering.markers = only.clustering.markers,
        acquired_markers = acquired_markers,
        uniform.test = "both",
        th.pvalue = 0.05,
        th.IQR = 2,
        verbose = FALSE
      )


    diagnostic.graph <-
      QC.to.curve(collection.U = collection.U,
                  basedata = basedata,
                  ggtitle = ggtitle)

    diagnostic.graph$ggplot
    diagnostic.graph[["metaclustering.list"]] <- metaclustering.list
    diagnostic.graph[["Accuracy.sets"]] <- collection.U[[2]]
    class(diagnostic.graph)<- "inflect.results"
    return(diagnostic.graph)
  }
